{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://lcccc.com.cn"},"pages":[{"title":"Repositories","date":"2018-09-11T06:05:18.458Z","updated":"2018-07-30T18:55:52.000Z","comments":false,"path":"repository/index.html","permalink":"http://lcccc.com.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-11T06:09:51.369Z","updated":"2018-09-11T06:09:51.369Z","comments":false,"path":"tags/index.html","permalink":"http://lcccc.com.cn/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-09-11T05:20:45.511Z","updated":"2018-09-11T05:20:45.511Z","comments":false,"path":"about/index.html","permalink":"http://lcccc.com.cn/about/index.html","excerpt":"","text":"轻轻的我走了正如我轻轻的来我轻轻的招手作别西天的云彩 那河畔的金柳是夕阳中的新娘波光里的艳影在我的心头荡漾 软泥上的青荇油油的在水底招摇在康河的柔波里我甘心做一条水草 那榆荫下的一潭不是清泉，是天上虹揉碎在浮躁间沉淀着彩虹似的梦 寻梦，撑一支长篙向青草更青处漫溯满载一船星辉在星辉斑斓里放歌 但我不能放歌悄悄是别离的笙箫夏虫也为我沉默沉默是今晚的康桥 悄悄的我走了正如我悄悄的来我挥一挥衣袖不带走一片云彩"},{"title":"分类","date":"2018-09-11T06:09:14.695Z","updated":"2018-09-11T06:09:14.695Z","comments":false,"path":"categories/index.html","permalink":"http://lcccc.com.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-09-11T06:40:37.839Z","updated":"2018-07-30T18:55:52.000Z","comments":true,"path":"links/index.html","permalink":"http://lcccc.com.cn/links/index.html","excerpt":"","text":""}],"posts":[{"title":"每周一记20190203","slug":"20190203","date":"2019-02-03T11:05:23.000Z","updated":"2019-02-03T11:06:05.399Z","comments":true,"path":"2019/02/03/20190203/","link":"","permalink":"http://lcccc.com.cn/2019/02/03/20190203/","excerpt":"","text":"每周一记20190203美团技术团队如何停止使用 console.log() 转而使用浏览器 debuggerThe best of JavaScript, HTML and CSSJavaScript常用工具方法封装 type 类型判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204isString (o) &#123; //是否字符串 return Object.prototype.toString.call(o).slice(8, -1) === &apos;String&apos;&#125;isNumber (o) &#123; //是否数字 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Number&apos;&#125;isBoolean (o) &#123; //是否boolean return Object.prototype.toString.call(o).slice(8, -1) === &apos;Boolean&apos;&#125;isFunction (o) &#123; //是否函数 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Function&apos;&#125;isNull (o) &#123; //是否为null return Object.prototype.toString.call(o).slice(8, -1) === &apos;Null&apos;&#125;isUndefined (o) &#123; //是否undefined return Object.prototype.toString.call(o).slice(8, -1) === &apos;Undefined&apos;&#125;isObj (o) &#123; //是否对象 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Object&apos;&#125;isArray (o) &#123; //是否数组 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Array&apos;&#125;isDate (o) &#123; //是否时间 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Date&apos;&#125;isRegExp (o) &#123; //是否正则 return Object.prototype.toString.call(o).slice(8, -1) === &apos;RegExp&apos;&#125;isError (o) &#123; //是否错误对象 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Error&apos;&#125;isSymbol (o) &#123; //是否Symbol函数 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Symbol&apos;&#125;isPromise (o) &#123; //是否Promise对象 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Promise&apos;&#125;isSet (o) &#123; //是否Set对象 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Set&apos;&#125;isFalse (o) &#123; if (!o || o === &apos;null&apos; || o === &apos;undefined&apos; || o === &apos;false&apos; || o === &apos;NaN&apos;) return true return false&#125;isTrue (o) &#123; return !this.isFalse(o)&#125;isIos () &#123; var u = navigator.userAgent; if (u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1) &#123;//安卓手机 // return &quot;Android&quot;; return false &#125; else if (u.indexOf(&apos;iPhone&apos;) &gt; -1) &#123;//苹果手机 // return &quot;iPhone&quot;; return true &#125; else if (u.indexOf(&apos;iPad&apos;) &gt; -1) &#123;//iPad // return &quot;iPad&quot;; return false &#125; else if (u.indexOf(&apos;Windows Phone&apos;) &gt; -1) &#123;//winphone手机 // return &quot;Windows Phone&quot;; return false &#125;else&#123; return false &#125;&#125;isPC () &#123; //是否为PC端 var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag;&#125;browserType()&#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器 var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器 var isIE11 = userAgent.indexOf(&apos;Trident&apos;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;rv:11.0&quot;) &gt; -1; var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1 &amp;&amp; !isIE; //判断是否IE的Edge浏览器 var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器 var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) == -1; //判断是否Safari浏览器 var isChrome = userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1; //判断Chrome浏览器 if (isIE) &#123; var reIE = new RegExp(&quot;MSIE (\\\\d+\\\\.\\\\d+);&quot;); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]); if(fIEVersion == 7) return &quot;IE7&quot; else if(fIEVersion == 8) return &quot;IE8&quot;; else if(fIEVersion == 9) return &quot;IE9&quot;; else if(fIEVersion == 10) return &quot;IE10&quot;; else return &quot;IE7以下&quot;//IE版本过低 &#125; if (isIE11) return &apos;IE11&apos;; if (isEdge) return &quot;Edge&quot;; if (isFF) return &quot;FF&quot;; if (isOpera) return &quot;Opera&quot;; if (isSafari) return &quot;Safari&quot;; if (isChrome) return &quot;Chrome&quot;;&#125;checkStr (str, type) &#123; switch (type) &#123; case &apos;phone&apos;: //手机号码 return /^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$/.test(str); case &apos;tel&apos;: //座机 return /^(0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)(-\\d&#123;1,4&#125;)?$/.test(str); case &apos;card&apos;: //身份证 return /(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/.test(str); case &apos;pwd&apos;: //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 return /^[a-zA-Z]\\w&#123;5,17&#125;$/.test(str) case &apos;postal&apos;: //邮政编码 return /[1-9]\\d&#123;5&#125;(?!\\d)/.test(str); case &apos;QQ&apos;: //QQ号 return /^[1-9][0-9]&#123;4,9&#125;$/.test(str); case &apos;email&apos;: //邮箱 return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str); case &apos;money&apos;: //金额(小数点2位) return /^\\d*(?:\\.\\d&#123;0,2&#125;)?$/.test(str); case &apos;URL&apos;: //网址 return /(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:/~\\+#]*[\\w\\-\\@?^=%&amp;/~\\+#])?/.test(str) case &apos;IP&apos;: //IP return /((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))/.test(str); case &apos;date&apos;: //日期时间 return /^(\\d&#123;4&#125;)\\-(\\d&#123;2&#125;)\\-(\\d&#123;2&#125;) (\\d&#123;2&#125;)(?:\\:\\d&#123;2&#125;|:(\\d&#123;2&#125;):(\\d&#123;2&#125;))$/.test(str) || /^(\\d&#123;4&#125;)\\-(\\d&#123;2&#125;)\\-(\\d&#123;2&#125;)$/.test(str) case &apos;number&apos;: //数字 return /^[0-9]$/.test(str); case &apos;english&apos;: //英文 return /^[a-zA-Z]+$/.test(str); case &apos;chinese&apos;: //中文 return /^[\\u4E00-\\u9FA5]+$/.test(str); case &apos;lower&apos;: //小写 return /^[a-z]+$/.test(str); case &apos;upper&apos;: //大写 return /^[A-Z]+$/.test(str); case &apos;HTML&apos;: //HTML标记 return /&lt;(&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|[^&apos;&quot;&gt;])*&gt;/.test(str); default: return true; &#125; // 严格的身份证校验 isCardID(sId) &#123; if (!/(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/.test(sId)) &#123; alert(&apos;你输入的身份证长度或格式错误&apos;) return false &#125; //身份证城市 var aCity=&#123;11:&quot;北京&quot;,12:&quot;天津&quot;,13:&quot;河北&quot;,14:&quot;山西&quot;,15:&quot;内蒙古&quot;,21:&quot;辽宁&quot;,22:&quot;吉林&quot;,23:&quot;黑龙江&quot;,31:&quot;上海&quot;,32:&quot;江苏&quot;,33:&quot;浙江&quot;,34:&quot;安徽&quot;,35:&quot;福建&quot;,36:&quot;江西&quot;,37:&quot;山东&quot;,41:&quot;河南&quot;,42:&quot;湖北&quot;,43:&quot;湖南&quot;,44:&quot;广东&quot;,45:&quot;广西&quot;,46:&quot;海南&quot;,50:&quot;重庆&quot;,51:&quot;四川&quot;,52:&quot;贵州&quot;,53:&quot;云南&quot;,54:&quot;西藏&quot;,61:&quot;陕西&quot;,62:&quot;甘肃&quot;,63:&quot;青海&quot;,64:&quot;宁夏&quot;,65:&quot;新疆&quot;,71:&quot;台湾&quot;,81:&quot;香港&quot;,82:&quot;澳门&quot;,91:&quot;国外&quot;&#125;; if(!aCity[parseInt(sId.substr(0,2))]) &#123; alert(&apos;你的身份证地区非法&apos;) return false &#125; // 出生日期验证 var sBirthday=(sId.substr(6,4)+&quot;-&quot;+Number(sId.substr(10,2))+&quot;-&quot;+Number(sId.substr(12,2))).replace(/-/g,&quot;/&quot;), d = new Date(sBirthday) if(sBirthday != (d.getFullYear()+&quot;/&quot;+ (d.getMonth()+1) + &quot;/&quot; + d.getDate())) &#123; alert(&apos;身份证上的出生日期非法&apos;) return false &#125; // 身份证号码校验 var sum = 0, weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2], codes = &quot;10X98765432&quot; for (var i = 0; i &lt; sId.length - 1; i++) &#123; sum += sId[i] * weights[i]; &#125; var last = codes[sum % 11]; //计算出来的最后一位身份证号码 if (sId[sId.length-1] != last) &#123; alert(&apos;你输入的身份证号非法&apos;) return false &#125; return true &#125;&#125; Date 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214/** * 格式化时间 * * @param &#123;time&#125; 时间 * @param &#123;cFormat&#125; 格式 * @return &#123;String&#125; 字符串 * * @example formatTime(&apos;2018-1-29&apos;, &apos;&#123;y&#125;/&#123;m&#125;/&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;&apos;) // -&gt; 2018/01/29 00:00:00 */formatTime(time, cFormat) &#123; if (arguments.length === 0) return null if ((time + &apos;&apos;).length === 10) &#123; time = +time * 1000 &#125; var format = cFormat || &apos;&#123;y&#125;-&#123;m&#125;-&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;&apos;, date if (typeof time === &apos;object&apos;) &#123; date = time &#125; else &#123; date = new Date(time) &#125; var formatObj = &#123; y: date.getFullYear(), m: date.getMonth() + 1, d: date.getDate(), h: date.getHours(), i: date.getMinutes(), s: date.getSeconds(), a: date.getDay() &#125; var time_str = format.replace(/&#123;(y|m|d|h|i|s|a)+&#125;/g, (result, key) =&gt; &#123; var value = formatObj[key] if (key === &apos;a&apos;) return [&apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;, &apos;日&apos;][value - 1] if (result.length &gt; 0 &amp;&amp; value &lt; 10) &#123; value = &apos;0&apos; + value &#125; return value || 0 &#125;) return time_str&#125;/** * 返回指定长度的月份集合 * * @param &#123;time&#125; 时间 * @param &#123;len&#125; 长度 * @param &#123;direction&#125; 方向： 1: 前几个月; 2: 后几个月; 3:前后几个月 默认 3 * @return &#123;Array&#125; 数组 * * @example getMonths(&apos;2018-1-29&apos;, 6, 1) // -&gt; [&quot;2018-1&quot;, &quot;2017-12&quot;, &quot;2017-11&quot;, &quot;2017-10&quot;, &quot;2017-9&quot;, &quot;2017-8&quot;, &quot;2017-7&quot;] */getMonths(time, len, direction) &#123; var mm = new Date(time).getMonth(), yy = new Date(time).getFullYear(), direction = isNaN(direction) ? 3 : direction, index = mm; var cutMonth = function(index) &#123; if ( index &lt;= len &amp;&amp; index &gt;= -len) &#123; return direction === 1 ? formatPre(index).concat(cutMonth(++index)): direction === 2 ? formatNext(index).concat(cutMonth(++index)):formatCurr(index).concat(cutMonth(++index)) &#125; return [] &#125; var formatNext = function(i) &#123; var y = Math.floor(i/12), m = i%12 return [yy+y + &apos;-&apos; + (m+1)] &#125; var formatPre = function(i) &#123; var y = Math.ceil(i/12), m = i%12 m = m===0 ? 12 : m return [yy-y + &apos;-&apos; + (13 - m)] &#125; var formatCurr = function(i) &#123; var y = Math.floor(i/12), yNext = Math.ceil(i/12), m = i%12, mNext = m===0 ? 12 : m return [yy-yNext + &apos;-&apos; + (13 - mNext),yy+y + &apos;-&apos; + (m+1)] &#125; // 数组去重 var unique = function(arr) &#123; if ( Array.hasOwnProperty(&apos;from&apos;) ) &#123; return Array.from(new Set(arr)); &#125;else&#123; var n = &#123;&#125;,r=[]; for(var i = 0; i &lt; arr.length; i++)&#123; if (!n[arr[i]])&#123; n[arr[i]] = true; r.push(arr[i]); &#125; &#125; return r; &#125; &#125; return direction !== 3 ? cutMonth(index) : unique(cutMonth(index).sort(function(t1, t2)&#123; return new Date(t1).getTime() - new Date(t2).getTime() &#125;))&#125;/** * 返回指定长度的天数集合 * * @param &#123;time&#125; 时间 * @param &#123;len&#125; 长度 * @param &#123;direction&#125; 方向： 1: 前几天; 2: 后几天; 3:前后几天 默认 3 * @return &#123;Array&#125; 数组 * * @example date.getDays(&apos;2018-1-29&apos;, 6) // -&gt; [&quot;2018-1-26&quot;, &quot;2018-1-27&quot;, &quot;2018-1-28&quot;, &quot;2018-1-29&quot;, &quot;2018-1-30&quot;, &quot;2018-1-31&quot;, &quot;2018-2-1&quot;] */getDays(time, len, diretion) &#123; var tt = new Date(time) var getDay = function(day) &#123; var t = new Date(time) t.setDate(t.getDate() + day) var m = t.getMonth()+1 return t.getFullYear()+&apos;-&apos;+m+&apos;-&apos;+t.getDate() &#125; var arr = [] if (diretion === 1) &#123; for (var i = 1; i &lt;= len; i++) &#123; arr.unshift(getDay(-i)) &#125; &#125;else if(diretion === 2) &#123; for (var i = 1; i &lt;= len; i++) &#123; arr.push(getDay(i)) &#125; &#125;else &#123; for (var i = 1; i &lt;= len; i++) &#123; arr.unshift(getDay(-i)) &#125; arr.push(tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()) for (var i = 1; i &lt;= len; i++) &#123; arr.push(getDay(i)) &#125; &#125; return diretion === 1 ? arr.concat([tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()]) : diretion === 2 ? [tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()].concat(arr) : arr&#125;/** * @param &#123;s&#125; 秒数 * @return &#123;String&#125; 字符串 * * @example formatHMS(3610) // -&gt; 1h0m10s */formatHMS (s) &#123; var str = &apos;&apos; if (s &gt; 3600) &#123; str = Math.floor(s/3600)+&apos;h&apos;+Math.floor(s%3600/60)+&apos;m&apos;+s%60+&apos;s&apos; &#125;else if(s &gt; 60) &#123; str = Math.floor(s/60)+&apos;m&apos;+s%60+&apos;s&apos; &#125;else&#123; str = s%60+&apos;s&apos; &#125; return str&#125;/*获取某月有多少天*/getMonthOfDay (time) &#123; var date = new Date(time) var year = date.getFullYear() var mouth = date.getMonth() + 1 var days //当月份为二月时，根据闰年还是非闰年判断天数 if (mouth == 2) &#123; days = (year%4==0 &amp;&amp; year%100==0 &amp;&amp; year%400==0) || (year%4==0 &amp;&amp; year%100!=0) ? 28 : 29 &#125; else if (mouth == 1 || mouth == 3 || mouth == 5 || mouth == 7 || mouth == 8 || mouth == 10 || mouth == 12) &#123; //月份为：1,3,5,7,8,10,12 时，为大月.则天数为31； days = 31 &#125; else &#123; //其他月份，天数为：30. days = 30 &#125; return days&#125;/*获取某年有多少天*/getYearOfDay (time) &#123; var firstDayYear = this.getFirstDayOfYear(time); var lastDayYear = this.getLastDayOfYear(time); var numSecond = (new Date(lastDayYear).getTime() - new Date(firstDayYear).getTime())/1000; return Math.ceil(numSecond/(24*3600));&#125;/*获取某年的第一天*/getFirstDayOfYear (time) &#123; var year = new Date(time).getFullYear(); return year + &quot;-01-01 00:00:00&quot;;&#125;/*获取某年最后一天*/getLastDayOfYear (time) &#123; var year = new Date(time).getFullYear(); var dateString = year + &quot;-12-01 00:00:00&quot;; var endDay = this.getMonthOfDay(dateString); return year + &quot;-12-&quot; + endDay + &quot; 23:59:59&quot;;&#125;/*获取某个日期是当年中的第几天*/getDayOfYear (time) &#123; var firstDayYear = this.getFirstDayOfYear(time); var numSecond = (new Date(time).getTime() - new Date(firstDayYear).getTime())/1000; return Math.ceil(numSecond/(24*3600));&#125;/*获取某个日期在这一年的第几周*/getDayOfYearWeek (time) &#123; var numdays = this.getDayOfYear(time); return Math.ceil(numdays / 7);&#125; Array 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/*判断一个元素是否在数组中*/contains (arr, val) &#123; return arr.indexOf(val) != -1 ? true : false;&#125;/** * @param &#123;arr&#125; 数组 * @param &#123;fn&#125; 回调函数 * @return &#123;undefined&#125; */each (arr, fn) &#123; fn = fn || Function; var a = []; var args = Array.prototype.slice.call(arguments, 1); for(var i = 0; i &lt; arr.length; i++) &#123; var res = fn.apply(arr, [arr[i], i].concat(args)); if(res != null) a.push(res); &#125;&#125;/** * @param &#123;arr&#125; 数组 * @param &#123;fn&#125; 回调函数 * @param &#123;thisObj&#125; this指向 * @return &#123;Array&#125; */map (arr, fn, thisObj) &#123; var scope = thisObj || window; var a = []; for(var i = 0, j = arr.length; i &lt; j; ++i) &#123; var res = fn.call(scope, arr[i], i, this); if(res != null) a.push(res); &#125; return a;&#125;/** * @param &#123;arr&#125; 数组 * @param &#123;type&#125; 1：从小到大 2：从大到小 3：随机 * @return &#123;Array&#125; */sort (arr, type = 1) &#123; return arr.sort( (a, b) =&gt; &#123; switch(type) &#123; case 1: return a - b; case 2: return b - a; case 3: return Math.random() - 0.5; default: return arr; &#125; &#125;)&#125;/*去重*/unique (arr) &#123; if ( Array.hasOwnProperty(&apos;from&apos;) ) &#123; return Array.from(new Set(arr)); &#125;else&#123; var n = &#123;&#125;,r=[]; for(var i = 0; i &lt; arr.length; i++)&#123; if (!n[arr[i]])&#123; n[arr[i]] = true; r.push(arr[i]); &#125; &#125; return r; &#125; // 注：上面 else 里面的排重并不能区分 2 和 &apos;2&apos;，但能减少用indexOf带来的性能,暂时没找到替代的方法。。。 /* 正确排重 if ( Array.hasOwnProperty(&apos;from&apos;) ) &#123; return Array.from(new Set(arr)) &#125;else&#123; var r = [], NaNBol = true for(var i=0; i &lt; arr.length; i++) &#123; if (arr[i] !== arr[i]) &#123; if (NaNBol &amp;&amp; r.indexOf(arr[i]) === -1) &#123; r.push(arr[i]) NaNBol = false &#125; &#125;else&#123; if(r.indexOf(arr[i]) === -1) r.push(arr[i]) &#125; &#125; return r &#125; */&#125;/*求两个集合的并集*/union (a, b) &#123; var newArr = a.concat(b); return this.unique(newArr);&#125;/*求两个集合的交集*/intersect (a, b) &#123; var _this = this; a = this.unique(a); return this.map(a, function(o) &#123; return _this.contains(b, o) ? o : null; &#125;);&#125;/*删除其中一个元素*/remove (arr, ele) &#123; var index = arr.indexOf(ele); if(index &gt; -1) &#123; arr.splice(index, 1); &#125; return arr;&#125;/*将类数组转换为数组的方法*/formArray (ary) &#123; var arr = []; if(Array.isArray(ary)) &#123; arr = ary; &#125; else &#123; arr = Array.prototype.slice.call(ary); &#125;; return arr;&#125;/*最大值*/max (arr) &#123; return Math.max.apply(null, arr);&#125;/*最小值*/min (arr) &#123; return Math.min.apply(null, arr);&#125;/*求和*/sum (arr) &#123; return arr.reduce( (pre, cur) =&gt; &#123; return pre + cur &#125;)&#125;/*平均值*/average (arr) &#123; return this.sum(arr)/arr.length&#125; String 字符串操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 去除空格 * @param &#123;str&#125; * @param &#123;type&#125; * type: 1-所有空格 2-前后空格 3-前空格 4-后空格 * @return &#123;String&#125; */trim (str, type) &#123; type = type || 1 switch (type) &#123; case 1: return str.replace(/\\s+/g, &quot;&quot;); case 2: return str.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;); case 3: return str.replace(/(^\\s*)/g, &quot;&quot;); case 4: return str.replace(/(\\s*$)/g, &quot;&quot;); default: return str; &#125;&#125;/** * @param &#123;str&#125; * @param &#123;type&#125; * type: 1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写 * @return &#123;String&#125; */changeCase (str, type) &#123; type = type || 4 switch (type) &#123; case 1: return str.replace(/\\b\\w+\\b/g, function (word) &#123; return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase(); &#125;); case 2: return str.replace(/\\b\\w+\\b/g, function (word) &#123; return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase(); &#125;); case 3: return str.split(&apos;&apos;).map( function(word)&#123; if (/[a-z]/.test(word)) &#123; return word.toUpperCase(); &#125;else&#123; return word.toLowerCase() &#125; &#125;).join(&apos;&apos;) case 4: return str.toUpperCase(); case 5: return str.toLowerCase(); default: return str; &#125;&#125;/* 检测密码强度*/checkPwd (str) &#123; var Lv = 0; if (str.length &lt; 6) &#123; return Lv &#125; if (/[0-9]/.test(str)) &#123; Lv++ &#125; if (/[a-z]/.test(str)) &#123; Lv++ &#125; if (/[A-Z]/.test(str)) &#123; Lv++ &#125; if (/[\\.|-|_]/.test(str)) &#123; Lv++ &#125; return Lv;&#125;/*过滤html代码(把&lt;&gt;转换)*/filterTag (str) &#123; str = str.replace(/&amp;/ig, &quot;&amp;amp;&quot;); str = str.replace(/&lt;/ig, &quot;&amp;lt;&quot;); str = str.replace(/&gt;/ig, &quot;&amp;gt;&quot;); str = str.replace(&quot; &quot;, &quot;&amp;nbsp;&quot;); return str;&#125; Number 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/*随机数范围*/random (min, max) &#123; if (arguments.length === 2) &#123; return Math.floor(min + Math.random() * ( (max+1) - min )) &#125;else&#123; return null; &#125;&#125;/*将阿拉伯数字翻译成中文的大写数字*/numberToChinese (num) &#123; var AA = new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;); var BB = new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;); var a = (&quot;&quot; + num).replace(/(^0*)/g, &quot;&quot;).split(&quot;.&quot;), k = 0, re = &quot;&quot;; for(var i = a[0].length - 1; i &gt;= 0; i--) &#123; switch(k) &#123; case 0: re = BB[7] + re; break; case 4: if(!new RegExp(&quot;0&#123;4&#125;//d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;) .test(a[0])) re = BB[4] + re; break; case 8: re = BB[5] + re; BB[7] = BB[5]; k = 0; break; &#125; if(k % 4 == 2 &amp;&amp; a[0].charAt(i + 2) != 0 &amp;&amp; a[0].charAt(i + 1) == 0) re = AA[0] + re; if(a[0].charAt(i) != 0) re = AA[a[0].charAt(i)] + BB[k % 4] + re; k++; &#125; if(a.length &gt; 1) // 加上小数部分(如果有小数部分) &#123; re += BB[6]; for(var i = 0; i &lt; a[1].length; i++) re += AA[a[1].charAt(i)]; &#125; if(re == &apos;一十&apos;) re = &quot;十&quot;; if(re.match(/^一/) &amp;&amp; re.length == 3) re = re.replace(&quot;一&quot;, &quot;&quot;); return re;&#125;/*将数字转换为大写金额*/changeToChinese (Num) &#123; //判断如果传递进来的不是字符的话转换为字符 if(typeof Num == &quot;number&quot;) &#123; Num = new String(Num); &#125;; Num = Num.replace(/,/g, &quot;&quot;) //替换tomoney()中的“,” Num = Num.replace(/ /g, &quot;&quot;) //替换tomoney()中的空格 Num = Num.replace(/￥/g, &quot;&quot;) //替换掉可能出现的￥字符 if(isNaN(Num)) &#123; //验证输入的字符是否为数字 //alert(&quot;请检查小写金额是否正确&quot;); return &quot;&quot;; &#125;; //字符处理完毕后开始转换，采用前后两部分分别转换 var part = String(Num).split(&quot;.&quot;); var newchar = &quot;&quot;; //小数点前进行转化 for(var i = part[0].length - 1; i &gt;= 0; i--) &#123; if(part[0].length &gt; 10) &#123; return &quot;&quot;; //若数量超过拾亿单位，提示 &#125; var tmpnewchar = &quot;&quot; var perchar = part[0].charAt(i); switch(perchar) &#123; case &quot;0&quot;: tmpnewchar = &quot;零&quot; + tmpnewchar; break; case &quot;1&quot;: tmpnewchar = &quot;壹&quot; + tmpnewchar; break; case &quot;2&quot;: tmpnewchar = &quot;贰&quot; + tmpnewchar; break; case &quot;3&quot;: tmpnewchar = &quot;叁&quot; + tmpnewchar; break; case &quot;4&quot;: tmpnewchar = &quot;肆&quot; + tmpnewchar; break; case &quot;5&quot;: tmpnewchar = &quot;伍&quot; + tmpnewchar; break; case &quot;6&quot;: tmpnewchar = &quot;陆&quot; + tmpnewchar; break; case &quot;7&quot;: tmpnewchar = &quot;柒&quot; + tmpnewchar; break; case &quot;8&quot;: tmpnewchar = &quot;捌&quot; + tmpnewchar; break; case &quot;9&quot;: tmpnewchar = &quot;玖&quot; + tmpnewchar; break; &#125; switch(part[0].length - i - 1) &#123; case 0: tmpnewchar = tmpnewchar + &quot;元&quot;; break; case 1: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;; break; case 2: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;; break; case 3: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;; break; case 4: tmpnewchar = tmpnewchar + &quot;万&quot;; break; case 5: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;; break; case 6: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;; break; case 7: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;; break; case 8: tmpnewchar = tmpnewchar + &quot;亿&quot;; break; case 9: tmpnewchar = tmpnewchar + &quot;拾&quot;; break; &#125; var newchar = tmpnewchar + newchar; &#125; //小数点之后进行转化 if(Num.indexOf(&quot;.&quot;) != -1) &#123; if(part[1].length &gt; 2) &#123; // alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;); part[1] = part[1].substr(0, 2) &#125; for(i = 0; i &lt; part[1].length; i++) &#123; tmpnewchar = &quot;&quot; perchar = part[1].charAt(i) switch(perchar) &#123; case &quot;0&quot;: tmpnewchar = &quot;零&quot; + tmpnewchar; break; case &quot;1&quot;: tmpnewchar = &quot;壹&quot; + tmpnewchar; break; case &quot;2&quot;: tmpnewchar = &quot;贰&quot; + tmpnewchar; break; case &quot;3&quot;: tmpnewchar = &quot;叁&quot; + tmpnewchar; break; case &quot;4&quot;: tmpnewchar = &quot;肆&quot; + tmpnewchar; break; case &quot;5&quot;: tmpnewchar = &quot;伍&quot; + tmpnewchar; break; case &quot;6&quot;: tmpnewchar = &quot;陆&quot; + tmpnewchar; break; case &quot;7&quot;: tmpnewchar = &quot;柒&quot; + tmpnewchar; break; case &quot;8&quot;: tmpnewchar = &quot;捌&quot; + tmpnewchar; break; case &quot;9&quot;: tmpnewchar = &quot;玖&quot; + tmpnewchar; break; &#125; if(i == 0) tmpnewchar = tmpnewchar + &quot;角&quot;; if(i == 1) tmpnewchar = tmpnewchar + &quot;分&quot;; newchar = newchar + tmpnewchar; &#125; &#125; //替换所有无用汉字 while(newchar.search(&quot;零零&quot;) != -1) newchar = newchar.replace(&quot;零零&quot;, &quot;零&quot;); newchar = newchar.replace(&quot;零亿&quot;, &quot;亿&quot;); newchar = newchar.replace(&quot;亿万&quot;, &quot;亿&quot;); newchar = newchar.replace(&quot;零万&quot;, &quot;万&quot;); newchar = newchar.replace(&quot;零元&quot;, &quot;元&quot;); newchar = newchar.replace(&quot;零角&quot;, &quot;&quot;); newchar = newchar.replace(&quot;零分&quot;, &quot;&quot;); if(newchar.charAt(newchar.length - 1) == &quot;元&quot;) &#123; newchar = newchar + &quot;整&quot; &#125; return newchar; &#125; Http 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * @param &#123;setting&#125; */ajax(setting)&#123; //设置参数的初始值 var opts=&#123; method: (setting.method || &quot;GET&quot;).toUpperCase(), //请求方式 url: setting.url || &quot;&quot;, // 请求地址 async: setting.async || true, // 是否异步 dataType: setting.dataType || &quot;json&quot;, // 解析方式 data: setting.data || &quot;&quot;, // 参数 success: setting.success || function()&#123;&#125;, // 请求成功回调 error: setting.error || function()&#123;&#125; // 请求失败回调 &#125; // 参数格式化 function params_format (obj) &#123; var str = &apos;&apos; for (var i in obj) &#123; str += i + &apos;=&apos; + obj[i] + &apos;&amp;&apos; &#125; return str.split(&apos;&apos;).slice(0, -1).join(&apos;&apos;) &#125; // 创建ajax对象 var xhr=new XMLHttpRequest(); // 连接服务器open(方法GET/POST，请求地址， 异步传输) if(opts.method == &apos;GET&apos;)&#123; xhr.open(opts.method, opts.url + &quot;?&quot; + params_format(opts.data), opts.async); xhr.send(); &#125;else&#123; xhr.open(opts.method, opts.url, opts.async); xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.send(opts.data); &#125; /* ** 每当readyState改变时，就会触发onreadystatechange事件 ** readyState属性存储有XMLHttpRequest的状态信息 ** 0 ：请求未初始化 ** 1 ：服务器连接已建立 ** 2 ：请求已接受 ** 3 : 请求处理中 ** 4 ：请求已完成，且相应就绪 */ xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; (xhr.status === 200 || xhr.status === 304)) &#123; switch(opts.dataType)&#123; case &quot;json&quot;: var json = JSON.parse(xhr.responseText); opts.success(json); break; case &quot;xml&quot;: opts.success(xhr.responseXML); break; default: opts.success(xhr.responseText); break; &#125; &#125; &#125; xhr.onerror = function(err) &#123; opts.error(err); &#125;&#125;/** * @param &#123;url&#125; * @param &#123;setting&#125; * @return &#123;Promise&#125; */fetch(url, setting) &#123; //设置参数的初始值 let opts=&#123; method: (setting.method || &apos;GET&apos;).toUpperCase(), //请求方式 headers : setting.headers || &#123;&#125;, // 请求头设置 credentials : setting.credentials || true, // 设置cookie是否一起发送 body: setting.body || &#123;&#125;, mode : setting.mode || &apos;no-cors&apos;, // 可以设置 cors, no-cors, same-origin redirect : setting.redirect || &apos;follow&apos;, // follow, error, manual cache : setting.cache || &apos;default&apos; // 设置 cache 模式 (default, reload, no-cache) &#125; let dataType = setting.dataType || &quot;json&quot;, // 解析方式 data = setting.data || &quot;&quot; // 参数 // 参数格式化 function params_format (obj) &#123; var str = &apos;&apos; for (var i in obj) &#123; str += `$&#123;i&#125;=$&#123;obj[i]&#125;&amp;` &#125; return str.split(&apos;&apos;).slice(0, -1).join(&apos;&apos;) &#125; if (opts.method === &apos;GET&apos;) &#123; url = url + (data?`?$&#123;params_format(data)&#125;`:&apos;&apos;) &#125;else&#123; setting.body = data || &#123;&#125; &#125; return new Promise( (resolve, reject) =&gt; &#123; fetch(url, opts).then( async res =&gt; &#123; let data = dataType === &apos;text&apos; ? await res.text() : dataType === &apos;blob&apos; ? await res.blob() : await res.json() resolve(data) &#125;).catch( e =&gt; &#123; reject(e) &#125;) &#125;)&#125; DOM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758$ (selector)&#123; var type = selector.substring(0, 1); if (type === &apos;#&apos;) &#123; if (document.querySelecotor) return document.querySelector(selector) return document.getElementById(selector.substring(1)) &#125;else if (type === &apos;.&apos;) &#123; if (document.querySelecotorAll) return document.querySelectorAll(selector) return document.getElementsByClassName(selector.substring(1)) &#125;else&#123; return document[&apos;querySelectorAll&apos; ? &apos;querySelectorAll&apos;:&apos;getElementsByTagName&apos;](selector) &#125;&#125; /*检测类名*/hasClass (ele, name) &#123; return ele.className.match(new RegExp(&apos;(\\\\s|^)&apos; + name + &apos;(\\\\s|$)&apos;));&#125;/*添加类名*/addClass (ele, name) &#123; if (!this.hasClass(ele, name)) ele.className += &quot; &quot; + name;&#125;/*删除类名*/removeClass (ele, name) &#123; if (this.hasClass(ele, name)) &#123; var reg = new RegExp(&apos;(\\\\s|^)&apos; + name + &apos;(\\\\s|$)&apos;); ele.className = ele.className.replace(reg, &apos;&apos;); &#125;&#125;/*替换类名*/replaceClass (ele, newName, oldName) &#123; this.removeClass(ele, oldName); this.addClass(ele, newName);&#125;/*获取兄弟节点*/siblings (ele) &#123; console.log(ele.parentNode) var chid = ele.parentNode.children,eleMatch = []; for(var i = 0, len = chid.length; i &lt; len; i ++)&#123; if(chid[i] != ele)&#123; eleMatch.push(chid[i]); &#125; &#125; return eleMatch;&#125;/*获取行间样式属性*/getByStyle (obj,name)&#123; if(obj.currentStyle)&#123; return obj.currentStyle[name]; &#125;else&#123; return getComputedStyle(obj,false)[name]; &#125;&#125; Storage 储存操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104class StorageFn &#123; constructor () &#123; this.ls = window.localStorage; this.ss = window.sessionStorage; &#125; /*-----------------cookie---------------------*/ /*设置cookie*/ setCookie (name, value, day) &#123; var setting = arguments[0]; if (Object.prototype.toString.call(setting).slice(8, -1) === &apos;Object&apos;)&#123; for (var i in setting) &#123; var oDate = new Date(); oDate.setDate(oDate.getDate() + day); document.cookie = i + &apos;=&apos; + setting[i] + &apos;;expires=&apos; + oDate; &#125; &#125;else&#123; var oDate = new Date(); oDate.setDate(oDate.getDate() + day); document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + oDate; &#125; &#125; /*获取cookie*/ getCookie (name) &#123; var arr = document.cookie.split(&apos;; &apos;); for (var i = 0; i &lt; arr.length; i++) &#123; var arr2 = arr[i].split(&apos;=&apos;); if (arr2[0] == name) &#123; return arr2[1]; &#125; &#125; return &apos;&apos;; &#125; /*删除cookie*/ removeCookie (name) &#123; this.setCookie(name, 1, -1); &#125; /*-----------------localStorage---------------------*/ /*设置localStorage*/ setLocal(key, val) &#123; var setting = arguments[0]; if (Object.prototype.toString.call(setting).slice(8, -1) === &apos;Object&apos;)&#123; for(var i in setting)&#123; this.ls.setItem(i, JSON.stringify(setting[i])) &#125; &#125;else&#123; this.ls.setItem(key, JSON.stringify(val)) &#125; &#125; /*获取localStorage*/ getLocal(key) &#123; if (key) return JSON.parse(this.ls.getItem(key)) return null; &#125; /*移除localStorage*/ removeLocal(key) &#123; this.ls.removeItem(key) &#125; /*移除所有localStorage*/ clearLocal() &#123; this.ls.clear() &#125; /*-----------------sessionStorage---------------------*/ /*设置sessionStorage*/ setSession(key, val) &#123; var setting = arguments[0]; if (Object.prototype.toString.call(setting).slice(8, -1) === &apos;Object&apos;)&#123; for(var i in setting)&#123; this.ss.setItem(i, JSON.stringify(setting[i])) &#125; &#125;else&#123; this.ss.setItem(key, JSON.stringify(val)) &#125; &#125; /*获取sessionStorage*/ getSession(key) &#123; if (key) return JSON.parse(this.ss.getItem(key)) return null; &#125; /*移除sessionStorage*/ removeSession(key) &#123; this.ss.removeItem(key) &#125; /*移除所有sessionStorage*/ clearSession() &#123; this.ss.clear() &#125;&#125; Other 其它操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*获取网址参数*/getURL(name)&#123; var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;); var r = decodeURI(window.location.search).substr(1).match(reg); if(r!=null) return r[2]; return null;&#125;/*获取全部url参数,并转换成json对象*/getUrlAllParams (url) &#123; var url = url ? url : window.location.href; var _pa = url.substring(url.indexOf(&apos;?&apos;) + 1), _arrS = _pa.split(&apos;&amp;&apos;), _rs = &#123;&#125;; for (var i = 0, _len = _arrS.length; i &lt; _len; i++) &#123; var pos = _arrS[i].indexOf(&apos;=&apos;); if (pos == -1) &#123; continue; &#125; var name = _arrS[i].substring(0, pos), value = window.decodeURIComponent(_arrS[i].substring(pos + 1)); _rs[name] = value; &#125; return _rs;&#125;/*删除url指定参数，返回url*/delParamsUrl(url, name)&#123; var baseUrl = url.split(&apos;?&apos;)[0] + &apos;?&apos;; var query = url.split(&apos;?&apos;)[1]; if (query.indexOf(name)&gt;-1) &#123; var obj = &#123;&#125; var arr = query.split(&quot;&amp;&quot;); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i].split(&quot;=&quot;); obj[arr[i][0]] = arr[i][1]; &#125;; delete obj[name]; var url = baseUrl + JSON.stringify(obj).replace(/[\\&quot;\\&#123;\\&#125;]/g,&quot;&quot;).replace(/\\:/g,&quot;=&quot;).replace(/\\,/g,&quot;&amp;&quot;); return url &#125;else&#123; return url; &#125;&#125;/*获取十六进制随机颜色*/getRandomColor () &#123; return &apos;#&apos; + (function(h) &#123; return new Array(7 - h.length).join(&quot;0&quot;) + h; &#125;)((Math.random() * 0x1000000 &lt;&lt; 0).toString(16));&#125;/*图片加载*/imgLoadAll(arr,callback)&#123; var arrImg = []; for (var i = 0; i &lt; arr.length; i++) &#123; var img = new Image(); img.src = arr[i]; img.onload = function()&#123; arrImg.push(this); if (arrImg.length == arr.length) &#123; callback &amp;&amp; callback(); &#125; &#125; &#125;&#125;/*音频加载*/loadAudio(src, callback) &#123; var audio = new Audio(src); audio.onloadedmetadata = callback; audio.src = src;&#125;/*DOM转字符串*/domToStirng(htmlDOM)&#123; var div= document.createElement(&quot;div&quot;); div.appendChild(htmlDOM); return div.innerHTML&#125;/*字符串转DOM*/stringToDom(htmlString)&#123; var div= document.createElement(&quot;div&quot;); div.innerHTML=htmlString; return div.children[0];&#125;/** * 光标所在位置插入字符，并设置光标位置 * * @param &#123;dom&#125; 输入框 * @param &#123;val&#125; 插入的值 * @param &#123;posLen&#125; 光标位置处在 插入的值的哪个位置 */setCursorPosition (dom,val,posLen) &#123; var cursorPosition = 0; if(dom.selectionStart)&#123; cursorPosition = dom.selectionStart; &#125; this.insertAtCursor(dom,val); dom.focus(); console.log(posLen) dom.setSelectionRange(dom.value.length,cursorPosition + (posLen || val.length));&#125;/*光标所在位置插入字符*/insertAtCursor(dom, val) &#123; if (document.selection)&#123; dom.focus(); sel = document.selection.createRange(); sel.text = val; sel.select(); &#125;else if (dom.selectionStart || dom.selectionStart == &apos;0&apos;)&#123; let startPos = dom.selectionStart; let endPos = dom.selectionEnd; let restoreTop = dom.scrollTop; dom.value = dom.value.substring(0, startPos) + val + dom.value.substring(endPos, dom.value.length); if (restoreTop &gt; 0)&#123; dom.scrollTop = restoreTop; &#125; dom.focus(); dom.selectionStart = startPos + val.length; dom.selectionEnd = startPos + val.length; &#125; else &#123; dom.value += val; dom.focus(); &#125;&#125; 谈谈super(props) 的重要性call、apply和bind方法的用法以及区别","categories":[],"tags":[]},{"title":"每周一记20190120","slug":"20190120","date":"2019-01-24T14:28:00.000Z","updated":"2019-01-24T14:28:26.689Z","comments":true,"path":"2019/01/24/20190120/","link":"","permalink":"http://lcccc.com.cn/2019/01/24/20190120/","excerpt":"","text":"每周一记20190120FindBugs-代码检查插件12帮助提高代码质量以及排除隐含的缺陷官方地址：http://findbugs.sourceforge.net/ Javascript数组操作React 模式一套 React 的 UI 组件库12预览地址: https://rsuitejs.com/Github: https://github.com/rsuite/rsuite","categories":[],"tags":[]},{"title":"每周一记20190113","slug":"20190113","date":"2019-01-13T09:09:56.000Z","updated":"2019-01-13T09:10:54.920Z","comments":true,"path":"2019/01/13/20190113/","link":"","permalink":"http://lcccc.com.cn/2019/01/13/20190113/","excerpt":"","text":"每周一记20190113Ant Design Pro内存溢出（out of memory）123node_modules/.bin 下umi.cmd 和webpack.cmd加上node -max-old-space-size=4096 一组匹配中国大陆手机号码的正则表达式。1https://github.com/VincentSit/ChinaMobilePhoneNumberRegex/blob/master/README-CN.md 每个 JavaScript 工程师都应懂的33个概念1https://github.com/stephentian/33-js-concepts Awesome Mac（收集非常好用的Mac应用程序、软件以及工具）1https://github.com/zzlw/awesome-mac react相关知识1https://www.geekjc.com/tag?type=post&amp;&amp;title=react 前端知识博客1https://github.com/ljianshu/Blog Docker 快速上手指南1https://segmentfault.com/a/1190000008822648","categories":[],"tags":[]},{"title":"每周一记20190105","slug":"20190105","date":"2019-01-05T08:50:03.000Z","updated":"2019-01-05T09:39:17.009Z","comments":true,"path":"2019/01/05/20190105/","link":"","permalink":"http://lcccc.com.cn/2019/01/05/20190105/","excerpt":"","text":"每周一记20190105==在js中优雅使用枚举==原文地址：Enums in Javascript翻译：如何在JavaScript中写枚举 one way123456789var SizeEnum = &#123; SMALL: 1, MEDIUM: 2, LARGE: 3,&#125;;Then use it like so:var mySize = SizeEnum.SMALL; the best way12345678910111213141516171819202122Object.freeze- Object.freeze()将一个对象进行冰冻: 他的意思是, 阻止添加新的属性, 阻止移除已存在的属性; 防止存在的属性，或其可数性、可配置性，或可性，被改变.- 实际上, 这个对象将有效的不可变了. 这个方法返回的是被冰冻的对象.-判断浏览器是否支持if (Object.freeze) Object.freeze(DaysEnum);var SizeEnum = &#123; SMALL: 1, MEDIUM: 2, LARGE: 3, properties: &#123; 1: &#123;name: &quot;small&quot;, value: 1, code: &quot;S&quot;&#125;, 2: &#123;name: &quot;medium&quot;, value: 2, code: &quot;M&quot;&#125;, 3: &#123;name: &quot;large&quot;, value: 3, code: &quot;L&quot;&#125; &#125;&#125;;Then use it like so:var mySize = SizeEnum.MEDIUM;var myCode = SizeEnum.properties[mySize].code; // myCode == &quot;M&quot; ==React16新特性==官方：React v16.0翻译： React v16.0（译） ==sessionStorage==123// 保存var obj=[&#123;&#125;,&#123;&#125;,&#123;&#125;]sessionStorage.setItem(&quot;key&quot;,JSON.stringify(obj)) 12// 获取var info=JSON.parse(sessionStorage.getItem(&quot;key&quot;)) ==npm命令相关==1234npm cache clean --force 清除缓存npm info module 查看依赖版本详细信息npm view mdule versions 查看依赖版本所有版本npm install module@latest -g 更新最新依赖版本 ==maven test==1234install -DskipTests -X install时不执行测试用例，但编译 -X是显示具体运行信息install -Dmaven.test.skip 跳过测试不编译install ==js判空函数==1234567891011121314151617function checkNull(value)&#123; if(!value || value == null || typeof value === &apos;undefined&apos;) || value === &apos;&apos;&#123; return true; &#125; return false;&#125;function isEmptyObject(object)&#123; if(checkNull(object))&#123; return true; &#125; if(Object.prototype.toString.call(object) === &apos;[Object Object]&apos;&amp;&amp; Object.keys(object).length=== 0)&#123; return true; &#125; return false;&#125;","categories":[],"tags":[]},{"title":"ant design form 表单","slug":"form","date":"2018-12-16T13:29:47.000Z","updated":"2018-12-16T13:32:24.417Z","comments":true,"path":"2018/12/16/form/","link":"","permalink":"http://lcccc.com.cn/2018/12/16/form/","excerpt":"","text":"ant design form 表单Form.create 包装的组件将会自带 this.props.form 属性12345const &#123; form &#125; = this.propsform.resetFields() 用于清空输入空form.validateFields 用于验证 自定义校验123456789101112&lt;FormItem &#123;...formItemLayout&#125; label=&quot;账号名&quot; hasFeedback&gt; &#123;getFieldDecorator(&apos;account&apos;, &#123; rules: [&#123; required: true, message: &apos;账号名不能为空&apos;, &#125;,&#123; validator: this.checkAccount, &#125;], initialValue: &apos;&apos; &#125;)( &lt;Input placeholder=&quot;手机号或邮箱号&quot;/&gt; )&#125; &lt;/FormItem&gt; 123456789checkAccount(rule, value, callback) &#123; var re = /^(\\w-*\\.*)+@(\\w-?)+(\\.\\w&#123;2,&#125;)+$/; if (value.length==11 || re.test(value)) &#123; callback(); &#125; else &#123; callback(&apos;账号名为邮箱或手机号&apos;); &#125; &#125;; Input输入框失焦的时候向服务端发送数据validateTrigger123456789101112131415161718&lt;Form.Item &#123;...formItemLayout&#125; label=&#123;HAP.languageChange(&apos;名称&apos;)&#125; hasFeedback &gt; &#123;getFieldDecorator(&apos;name&apos;, &#123; rules: [ &#123; required: true, whitespace: true, validator: this.checkName, &#125;, ], validateTrigger: &apos;onBlur&apos;, &#125;)( &lt;Input size=&quot;default&quot; /&gt;, )&#125; &lt;/Form.Item&gt; rules限制输入为数字12345678910rules: [&#123; required: true, whitespace: true, type:&apos;number&apos;, transform(value) &#123; if(value)&#123; return Number(value); &#125; &#125;, message: &apos;请输入联系方式&apos; &#125;],","categories":[],"tags":[{"name":"Ant Design Pro 2.0","slug":"Ant-Design-Pro-2-0","permalink":"http://lcccc.com.cn/tags/Ant-Design-Pro-2-0/"}]},{"title":"xshell中配置Java环境以及常用命令","slug":"xshell","date":"2018-11-12T14:24:50.000Z","updated":"2018-11-12T14:30:07.231Z","comments":true,"path":"2018/11/12/xshell/","link":"","permalink":"http://lcccc.com.cn/2018/11/12/xshell/","excerpt":"","text":"xshell中配置Java环境直接输入命令（JAVA_HOME为JDK的位置）1234567export JAVA_HOME=/usr/local/java/jdk1.8.0_131export JRE_HOME=/usr/local/java/jdk1.8.0_131/jreexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$JAVA_HOME/bin:$PATH 输入java -version有版本信息则成功 部署中常用命令1234567891011121314启动项目sh start.sh停止sh stop.sh实时查看日志tail -f logs/cims.log(日志位置)查看所有进程ps -ef|grep java杀进程 kill -9 端口号","categories":[],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"http://lcccc.com.cn/tags/Linux常用命令/"}]},{"title":"Git相关学习2","slug":"Git2","date":"2018-11-05T12:53:51.000Z","updated":"2018-11-05T12:59:26.421Z","comments":true,"path":"2018/11/05/Git2/","link":"","permalink":"http://lcccc.com.cn/2018/11/05/Git2/","excerpt":"","text":"Git常用命令 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 git remote123456查看所有远程主机名$ git remote 查看远程主机地址$ git remote -v 查看主机相关信息$ git remote show &lt;主机名&gt; git clone12克隆远程主机下的分支$ git clone -b &lt;主机地址&gt; &lt;分支名&gt; git pull12取回远程主机某个分支的更新$ git pull &lt;主机名&gt; &lt;分支名&gt; git push12将本地分支的更新，推送到远程主机$ git push &lt;主机名&gt; &lt;分支名&gt; git merge12在本地分支上合并远程分支$ git merge &lt;主机名&gt;/&lt;分支名&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://lcccc.com.cn/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://lcccc.com.cn/tags/Git/"}]},{"title":"在Raect中使用Echarts","slug":"Echarts","date":"2018-10-28T08:59:58.000Z","updated":"2018-10-28T09:03:02.113Z","comments":true,"path":"2018/10/28/Echarts/","link":"","permalink":"http://lcccc.com.cn/2018/10/28/Echarts/","excerpt":"","text":"在Raect中使用Echarts百度旗下出品：可视化数据Echarts 2.X官网 Echarts 3.X官网 Echarts的使用npm install echarts –save添加基本的react组件模型，一个render方法，定义了一个div容器来展示canvas，style初始化容器的宽度和高度，如果不设置，就无法渲染canvas，这里用到了ref来获取节点，而不是id。在react中，我们需要等到虚拟dom渲染完成了才能通过refs去获取节点，这样我们就可以在组件componentDidMount的时候初始化echarts。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React, &#123; Component&#125; from &apos;react&apos;;// 引入 ECharts 主模块import echarts from &apos;echarts/echarts&apos;;// 引入柱状图import &apos;echarts/chart/bar&apos;;// 引入提示框和标题组件import &apos;echarts/component/tooltip&apos;;import &apos;echarts/component/title&apos;;// import echarts from &apos;echarts/lib/echarts&apos;;// // 引入柱状图// import &apos;echarts/lib/chart/bar&apos;;// // 引入提示框和标题组件// import &apos;echarts/lib/component/tooltip&apos;;// import &apos;echarts/lib/component/title&apos;;class EchartsTest2 extends Component &#123; componentDidMount() &#123; // 基于准备好的dom，初始化echarts实例 const myChart = echarts.init(this.refs.main); // 指定图表的配置项和数据 const option = &#123; title: &#123; text: &apos;ECharts 入门示例&apos; &#125;, tooltip: &#123;&#125;, legend: &#123; data: [&apos;销量&apos;] &#125;, xAxis: &#123; data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &apos;销量&apos;, type: &apos;bar&apos;, data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表 myChart.setOption(option); &#125; render() &#123; return ( &lt;div ref=&quot;main&quot; style=&#123; &#123; width: 400, height: 400 &#125; &#125; /&gt; ); &#125;&#125;export default EchartsTest2; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React, &#123; Component &#125; from &apos;react&apos;;//导入echartsvar echarts = require(&apos;echarts/lib/echarts&apos;) //必须require(&apos;echarts/lib/chart/pie&apos;) //图表类型require(&apos;echarts/lib/component/title&apos;) //标题插件export class PieReact extends React.Component &#123; constructor(props) &#123; super(props) this.setPieOption = this.setPieOption.bind(this) this.initPie = this.initPie.bind(this) &#125; initPie() &#123; const &#123; data &#125; = this.props //外部传入的data数据 let myChart = echarts.init(this.refs.pieChart) //初始化echarts //我们要定义一个setPieOption函数将data传入option里面 let options = this.setPieOption(data) //设置options myChart.setOption(options) &#125; componentDidMount() &#123; this.initPie() &#125; componentDidUpdate() &#123; this.initPie() &#125; render() &#123; return ( &lt;div className=&quot;pie-react&quot;&gt; &lt;div ref=&quot;pieReact&quot; style=&#123;&#123;width: &quot;100%&quot;, height: &quot;200px&quot;&#125;&#125;&gt;&lt;/div&gt; &lt;/div&gt; ) &#125; //一个基本的echarts图表配置函数 setPieOption(data) &#123; return &#123; series : [ &#123; name: &apos;比例&apos;, type: &apos;pie&apos;, radius: [&apos;70%&apos;, &apos;90%&apos;], avoidLabelOverlap: true, data: data, //传入外部的data数据 label: &#123; normal: &#123; show: false, position: &apos;center&apos;, textStyle: &#123; fontSize: &apos;18&apos; &#125;, formatter: &quot;&#123;d&#125;% \\n&#123;b&#125;&quot;, &#125;, emphasis: &#123; show: true, textStyle: &#123; fontSize: &apos;18&apos;, &#125; &#125; &#125;, labelLine: &#123; normal: &#123; show: false &#125; &#125; &#125; ] &#125; &#125;&#125; echarts-for-react的使用（一个简单的 echarts(v3.0 &amp; v4.0) 的 react 封装）echarts-for-react的GitHub实现实例#####123npm install --save echarts-for-reactnpm install --save echarts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import React, &#123; Component &#125; from &apos;react&apos;;import ReactEcharts from &apos;echarts-for-react&apos;;// 引入 ECharts 主模块// 引入柱状图import &apos;echarts/chart/bar&apos;;// 引入提示框和标题组件import &apos;echarts/component/tooltip&apos;;import &apos;echarts/component/title&apos;;// 引入柱状图// import &apos;echarts/lib/chart/bar&apos;;// // 引入提示框和标题组件// import &apos;echarts/lib/component/tooltip&apos;;// import &apos;echarts/lib/component/title&apos;; class ReactEchartsTest extends Component &#123; getOption=()=&gt;&#123; // 指定图表的配置项和数据 option:接收一个对象，该对象为 echarts 的配置项 const option = &#123; title: &#123; text: &apos;ECharts 入门示例&apos; &#125;, tooltip: &#123;&#125;, legend: &#123; data: [&apos;销量&apos;] &#125;, xAxis: &#123; data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &apos;销量&apos;, type: &apos;bar&apos;, data: [5, 20, 36, 10, 10, 20], &#125;] &#125;; return option; &#125; // notMerge:可选，是否不跟之前设置的 option 进行合并，默认为 false，即合并。 // LazyUpdate:可选，在设置完 option 后是否不立即更新图表，默认为 false，即立即更新。 // style:echarts 容器 div 大小 render() &#123; return ( &lt;div&gt; &lt;ReactEcharts option=&#123;this.getOption()&#125; style=&#123; &#123; width: 400, height: 400 &#125; &#125; notMerge lazyUpdate theme=&quot;theme_name&quot; /&gt; &lt;/div&gt; ); &#125; &#125; export default ReactEchartsTest;","categories":[{"name":"React技术栈","slug":"React技术栈","permalink":"http://lcccc.com.cn/categories/React技术栈/"}],"tags":[{"name":"Ant Design Pro 2.0","slug":"Ant-Design-Pro-2-0","permalink":"http://lcccc.com.cn/tags/Ant-Design-Pro-2-0/"}]},{"title":"使用git pull文件时和本地文件冲突怎么办？","slug":"Gitpull","date":"2018-10-19T12:51:31.000Z","updated":"2018-10-19T14:22:29.837Z","comments":true,"path":"2018/10/19/Gitpull/","link":"","permalink":"http://lcccc.com.cn/2018/10/19/Gitpull/","excerpt":"","text":"Git冲突使用git pull文件时和本地文件冲突怎么办？12error: Your local changes to &apos;c/environ.c&apos; would be overwritten by merge. Aborting.Please, commit your changes or stash them before you can merge. 更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。 123场景一 user0 有新提交user1 没有pull -&gt; 写新代码 -&gt; pull -&gt; 提示有冲突 12解决办法一-&gt; stash save(把自己的代码隐藏存起来) -&gt; 重新pull -&gt; stash pop(把存起来的隐藏的代码取回来 ) -&gt; 代码文件会显示冲突 -&gt; 右键选择edit conficts，解决后点击编辑页面的 mark as resolved -&gt; commit&amp;push 12解决办法二(尽量少使用，这种方法的优点是在在原编辑器里处理冲突，代码逻辑看得更清楚一些)-&gt; stash save(把自己的代码隐藏存起来) -&gt; 重新pull -&gt; stash pop(把存起来的隐藏的代码取回来 ) -&gt; 代码文件会显示冲突 -&gt; 右键选择resolve conflict -&gt; 打开文件解决冲突 -&gt; commit&amp;push 123场景二user0 有新提交user1 没有pull -&gt; 写新代码 -&gt; commit&amp;push -&gt; 提示有冲突 12解决办法一-&gt; pull -&gt; 代码文件会显示冲突 -&gt; 右键选择edit conficts，解决后点击编辑页面的 mark as resolved -&gt; commit&amp;push","categories":[{"name":"工具","slug":"工具","permalink":"http://lcccc.com.cn/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://lcccc.com.cn/tags/Git/"}]},{"title":"Linux","slug":"Linux","date":"2018-10-17T15:01:10.000Z","updated":"2018-10-17T15:16:12.443Z","comments":true,"path":"2018/10/17/Linux/","link":"","permalink":"http://lcccc.com.cn/2018/10/17/Linux/","excerpt":"","text":"Linux常用命令cd命令123cd /root/Docements # 切换到目录/root/Docementscd ./path # 切换到当前目录下的path目录中，“.”表示当前目录 cd ../path # 切换到上层目录中的path目录中，“..”表示上一层目录 ls命令（查看文件与目录）12ls -l #以长数据串的形式列出当前目录下的数据文件和目录ls -lR #以长数据串的形式列出当前目录下的所有文件 rm命令12rm -i file # 删除文件file，在删除之前会询问是否进行该操作rm -fr dir # 强制删除目录dir中的所有文件 vim命令(文本编辑)pwd(显示当前目录)sz(下载)rz(上传)","categories":[],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"http://lcccc.com.cn/tags/Linux常用命令/"}]},{"title":"ES6实用性技能","slug":"es6","date":"2018-10-16T14:00:26.000Z","updated":"2018-10-16T14:13:22.489Z","comments":true,"path":"2018/10/16/es6/","link":"","permalink":"http://lcccc.com.cn/2018/10/16/es6/","excerpt":"","text":"ES6实用性技能函数js（es5）定义函数三种形式： 1234567891011121314//语句形式定义函数 function test1()&#123; alert(&quot;hello function1&quot;); &#125;//直接量形式定义函数var test2=function()&#123; alert(&quot;hello function2&quot;)； &#125;//直接量形式定义函数var test3=new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a+b&quot;);//调用函数test1();//输出hello function1test2();//输出hello function2alert(test3(1,2));//输出3 es6箭头函数 不需要 function 关键字来创建函数 省略 return 关键字 继承当前上下文的 this 关键字 123456//例如： [1,2,3].map(x =&gt; x + 1)//等同于： [1,2,3].map((function(x)&#123; return x + 1 &#125;).bind(this)) AntD Pro实用性技巧条件判断加载组件12&#123;this.state.xxx ? &lt;Form.Item&gt;&lt;/Form.Item&gt; ：null&#125;&#123;this.state.xxxx &amp;&amp; &lt;Form.Item&gt;&#125; 12345678910&#123;selectedRows.length &gt; 0 &amp;&amp; ( &lt;span&gt; &lt;Button&gt;批量操作&lt;/Button&gt; &lt;Dropdown overlay=&#123;menu&#125;&gt; &lt;Button&gt; 更多操作 &lt;Icon type=&quot;down&quot; /&gt; &lt;/Button&gt; &lt;/Dropdown&gt; &lt;/span&gt; )&#125; form表单下拉选中默认值1234567891011&lt;FormItem label=&quot;证件类型&quot;&gt; &#123;getFieldDecorator(&apos;status&apos;,&#123; initialValue:&quot;0&quot;, &#125;)( &lt;Select style=&#123;&#123; width: &apos;100%&apos; &#125;&#125;&gt; &lt;Option value=&quot;0&quot;&gt;二代身份证&lt;/Option&gt; &lt;Option value=&quot;1&quot;&gt;港澳通行证&lt;/Option&gt; &lt;Option value=&quot;2&quot;&gt;护照&lt;/Option&gt; &lt;Option value=&quot;3&quot;&gt;居住证&lt;/Option&gt; &lt;/Select&gt;)&#125;&lt;/FormItem&gt; 使用ES6的Object.keys()方法判断对象是否为空对象123const data = &#123;&#125;;const arr = Object.keys(data);alert(arr.length === 0);//true 对象的扩展（属性名表达式）12345// 方法一obj.foo = true;// 方法二obj[&apos;a&apos;+&apos;bc&apos;] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。但是，如果使用字面量方式定义对象（使用大括号），在ES5中只能使用方法一（标识符）定义属性。 1234var obj = &#123; foo: true, abc: 123&#125;; ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 123456let propKey = &apos;foo&apos;;let obj = &#123; [propKey]: true, [&apos;a&apos;+&apos;bc&apos;]: 123&#125;; 下面是另一个例子。 12345678910var lastWord = &quot;last word&quot;;var a = &#123; &quot;first word&quot;: &quot;hello&quot;, [lastWord]: &quot;world&quot;&#125;;a[&quot;first word&quot;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&quot;last word&quot;] // &quot;world&quot; 表达式还可以用于定义方法名。 1234567let obj = &#123; [&apos;h&apos;+&apos;ello&apos;]() &#123; return &apos;hi&apos;; &#125;&#125;;console.log(obj.hello()); // hi","categories":[{"name":"web前端","slug":"web前端","permalink":"http://lcccc.com.cn/categories/web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://lcccc.com.cn/tags/ES6/"}]},{"title":"React Router跳转及页面传值","slug":"routervalue","date":"2018-09-25T13:03:59.000Z","updated":"2018-09-28T12:12:01.929Z","comments":true,"path":"2018/09/25/routervalue/","link":"","permalink":"http://lcccc.com.cn/2018/09/25/routervalue/","excerpt":"","text":"React Router跳转及页面传值 to: string 1&lt;Link to=&apos;/courses?sort=name&apos;&gt;跳转&lt;Link&gt; to: object 123456&lt;Link to=&#123;&#123; pathname: &apos;/courses&apos;, search: &apos;?sort=name&apos;, hash: &apos;#the-hash&apos;, state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt; this.props.params1.定义路由 1&lt;Route path=&apos;/user/:id&apos; component=&#123;UserPage&#125;&gt;&lt;/Route&gt; 2.跳转前页面 1&lt;Link to=&#123;`/topics/$&#123;id&#125;`&#125; &gt;点击跳转&lt;/Link&gt; 3.获取参数 123this.props.params或者react-router v4高版本this.props.（match）.params.参数名 获取URL中的参数值 statestate方式依然可以传递任意类型的数据，而且可以不以明文方式传输。state传的参数是加密的 定义路由 1&lt;Route path= &apos; /user&apos; component= &#123;UserPage&#125;&gt;&lt;/Route&gt; 使用12const data = &#123;id:3,name:sam,age:36&#125;;const path = &#123;pathname: &apos; /user&apos;,state:data,&#125; 11.&lt;Link to=&#123;path&#125;&gt; 用户&lt;/Link&gt; 12342.import &#123; hashHistory &#125; from &apos;react-router&apos; hashHistory.push (path); // browserHistory.push(); 表单跳转// this.props.history.push(); 获取数据 123const data = this.props.location.state;(获取当前路由地址this.props.location.pathname)const &#123;id, name,age&#125; = data; 基于 action 进行页面跳转123456789101112131415import &#123; routerRedux &#125; from &apos;dva/router&apos;;// Inside Effectsyield put(routerRedux.push(&apos;/logout&apos;));// Outside Effectsdispatch(routerRedux.push(&apos;/logout&apos;));// With queryrouterRedux.push(&#123; pathname: &apos;/logout&apos;, query: &#123; page: 2, &#125;,&#125;); umi官方跳转umi/link1234567891011121314import Link from &apos;umi/link&apos;;export default () =&gt; &#123; &lt;div&gt; /* 普通使用 */ &lt;Link to=&quot;/list&quot;&gt;Go to list page&lt;/Link&gt; /* 带参数 */ &lt;Link to=&quot;/list?a=b&quot;&gt;Go to list page&lt;/Link&gt; /* 包含子组件 */ &lt;Link to=&quot;/list?a=b&quot;&gt;&lt;button&gt;Go to list page&lt;/button&gt;&lt;/Link&gt; &lt;/div&gt;&#125; umi/router1234567891011121314151617import router from &apos;umi/router&apos;;// 普通跳转，不带参数router.push(&apos;/list&apos;);// 带参数router.push(&apos;/list?a=b&apos;);router.push(&#123; pathname: &apos;/list&apos;, query: &#123; a: &apos;b&apos;, &#125;,&#125;);# 对象且不包含 pathname 会报错router.push(&#123; query: &#123;&#125;&#125;); 注意：pathname属性不要更改，否则出错","categories":[{"name":"React技术栈","slug":"React技术栈","permalink":"http://lcccc.com.cn/categories/React技术栈/"}],"tags":[{"name":"React-Router","slug":"React-Router","permalink":"http://lcccc.com.cn/tags/React-Router/"}]},{"title":"自建ss服务器教程","slug":"ssrbuild","date":"2018-09-22T12:06:23.000Z","updated":"2018-09-22T12:10:53.052Z","comments":true,"path":"2018/09/22/ssrbuild/","link":"","permalink":"http://lcccc.com.cn/2018/09/22/ssrbuild/","excerpt":"","text":"自建ss服务器教程2018.9.1更新：vultr官方进行了调整，2.5美元套餐只提供ipv6，如果你用不了ipv6，那么你可以买3.5美元的套餐。不怕被封ip，因为vultr是折算成小时计费，且可以随时删除和开通服务器，新服务器就是新的ip。新开服务器只需要0.01美元，即使你运气非常不好，开了10台服务器才获得没有被墙的ip，总创建服务器成本也只有0.1美元，不到1块钱。开通服务器时，当出现了ip，不要立马去ping或者用xshell去连接，再等5分钟之后，有个缓冲时间。 自建ss/ssr教程很简单，整个教程分三步： 第一步：购买VPS服务器 第二步：一键部署VPS服务器 第三步：一键加速VPS服务器 （谷歌BBR加速，推荐） 第一步：购买VPS服务器VPS服务器需要选择国外的，首选国际知名的vultr，速度不错、稳定且性价比高，按小时计费，能够随时开通和删除服务器，新服务器即是新ip。 vultr注册地址： http://www.vultr.com/?ref=7048874 （全球15个服务器位置可选，kvm框架，2.5美元/月。如果以后这个vultr注册地址被墙了，那么就用翻墙软件打开，或者用ss/ssr免费账号） 虽然是英文界面，但是现在的浏览器都有网页翻译功能，鼠标点击右键，选择网页翻译即可翻译成中文。 注册并邮件激活账号，充值后即可购买服务器。充值方式是支付宝或paypal，使用paypal有银行卡（包括信用卡）即可。paypal注册地址：https://www.paypal.com （paypal是国际知名的第三方支付服务商，注册一下账号，绑定银行卡即可购买国外商品） 2.5美元/月的服务器配置信息：单核 512M内存 20G SSD硬盘 带宽峰值100M 500G流量/月 (仅ipv6) 3.5美元/月的服务器配置信息：单核 512M内存 20G SSD硬盘 带宽峰值100M 500G流量/月 5美元/月的服务器配置信息： 单核 1G内存 25G SSD硬盘 带宽峰值100M 1000G流量/月 10美元/月的服务器配置信息： 单核 2G内存 40G SSD硬盘 带宽峰值100M 2000G流量/月 20美元/月的服务器配置信息： 2cpu 4G内存 60G SSD硬盘 带宽峰值100M 3000G流量/月 40美元/月的服务器配置信息： 4cpu 8G内存 100G SSD硬盘 带宽峰值100M 4000G流量/月 注意：vultr官方进行了调整，2.5美元套餐只提供ipv6，如果你用不了ipv6，那么你可以买3.5美元的套餐。 vultr实际上是折算成小时来计费的，比如服务器是5美元1个月，那么每小时收费为5/30/24=0.0069美元 会自动从账号中扣费，只要保证账号有钱即可。如果你部署的服务器实测后速度不理想，你可以把它删掉（destroy），重新换个地区的服务器来部署，方便且实用。因为新的服务器就是新的ip，所以当ip被墙时这个方法很有用。当ip被墙时，为了保证新开的服务器ip和原先的ip不一样，先开新服务器，开好后再删除旧服务器即可。 计费从你开通服务器开始算的，不管你有没有使用，即使服务器处于关机状态仍然会计费，如果你没有开通服务器就不算。比如你今天早上开通了服务器，但你有事情，晚上才部署，那么这段时间是会计费的。同理，如果你早上删掉服务器，第二天才开通新的服务器，那么这段时间是不会计费的。在账号的Billing选项里可以看到账户余额。 温馨提醒：同样的服务器位置，不同的宽带类型和地区所搭建的账号的翻墙速度会不同，这与中国电信、中国联通、中国移动国际出口带宽和线路不同有关，所以以实测为准。可以先选定一个服务器位置来按照教程进行搭建，熟悉搭建方法，当账号搭建完成并进行了bbr加速后，测试下速度自己是否满意，如果满意那就用这个服务器位置的服务器。如果速度不太满意，就一次性开几台不同的服务器位置的服务器，然后按照同样的方法来进行搭建并测试，选择最优的，之后把其它的服务器删掉，按小时计费测试成本可以忽略。 账号充值如图： 开通服务器步骤如图： 选择vps操作系统时，==不要选centos7系统==！点击图中的CentOS几个字，会弹出centos6，然后选中centos6！entos7默认的防火墙可能会干扰ssr的正常连接！接下来这一步是开启vps的ipv6 ip，选填项。如果你的电脑系统可以用ipv6，那么可以勾选此项。大多数用户没有这个需求，但有一些用户可能会用到，所以补充了这部分内容。 开通服务器时，当出现了ip，不要立马去ping或者用xshell去连接，再等5分钟之后，有个缓冲时间。完成购买后，找到系统的密码记下来，部署服务器时需要用到。vps系统（推荐centos6）的密码获取方法如下图： 如果你开启了vps的ipv6，那么在后台的settings选项可以找到服务器的ipv6 ip。在部署SSR账号时，你用ipv6 ip就行。整个部署及使用过程中，记得把电脑系统开启ipv6喔。 删掉服务器步骤如下图： 一个被墙ip的vps被删掉后，其ip并不会消失，会随机分配给下一个在这个服务器位置新建服务器的人，这就是为什么开新服务器会有一定几率开到被墙的ip。被墙是指在国内地区无法ping通服务器，但在国外是可以ping通的，vultr是面向全球服务，如果这个被墙ip被国外的人开到了，它是可以被正常使用的，半年或1年后这个被墙的ip可能会被国内防火墙解封，那么这就是一个良性循环。 第二步：部署VPS服务器购买服务器后，需要部署一下。因为你买的是虚拟东西，而且又远在国外，我们需要一个叫Xshell的软件来远程部署。Xshell windows版下载地址： 国外云盘1下载 国外云盘2下载 提取密码：666 国外云盘3下载 密码：123 如果你是苹果电脑操作系统，更简单，无需下载xshell，系统可以直接连接VPS。打开终端（Terminal），输入ssh root@ip 其中“ip”替换成你VPS的ip, 按回车键，然后复制粘贴密码，按回车键即可登录。粘贴密码时有可能不显示密码，但不影响， 参考设置方法 如果不能用MAC自带的终端连接的话，直接网上搜“MAC连接SSH的软件”，有很多，然后通过软件来连接vps服务器就行，具体操作方式参考windows xshell。 部署教程：下载windows xshell软件并安装后，打开软件 选择文件，新建 随便取个名字，然后把你的服务器ip填上 连接国外ip即服务器时，软件会先后提醒你输入用户名和密码，用户名默认都是root，密码是你购买的服务器系统的密码。 如果xshell连不上服务器，没有弹出让你输入用户名和密码的输入框，表明你开到的ip是一个被墙的ip，遇到这种情况，重新开新的服务器，直到能用xshell连上为止，耐心点哦！如果同一个地区开了多台服务器还是不行的话，可以换其它地区。 连接成功后，会出现如上图所示，之后就可以复制粘贴代码部署了。 CentOS6/Debian6/Ubuntu14 ShadowsocksR一键部署管理脚本： yum -y install wget wget -N –no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 备用脚本： yum -y install wget wget -N –no-check-certificate https://softs.wtf/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh ———————————————————代码分割线———————————————— 复制上面的代码到VPS服务器里，复制代码用鼠标右键的复制，然后在vps里面右键粘贴进去，因为ctrl+c和ctrl+v无效。接着按回车键，脚本会自动安装，以后只需要运行这个快捷命令就可以出现下图的界面进行设置，快捷管理命令为：bash ssr.sh 如上图出现管理界面后，输入数字1来安装SSR服务端。如果输入1后不能进入下一步，那么请退出xshell，重新连接vps服务器，然后输入快捷管理命令bash ssr.sh 再尝试。 根据上图提示，依次输入自己想设置的端口和密码 (密码建议用复杂点的字母组合，端口号为40-65535之间的数字)，回车键用于确认 注：关于端口的设置，总的网络总端口有6万多个，理论上可以任意设置，但不要以0开头！但是有的地区需要设置特殊的端口才有效，一些特殊的端口比如80、143、443、1433、3306、3389、8080。 如上图，选择想设置的加密方式，比如10，按回车键确认 接下来是选择协议插件，如下图： 选择并确认后，会出现上图的界面，提示你是否选择兼容原版，这里的原版指的是SS客户端（SS客户端没有协议和混淆的选项），可以根据需求进行选择，演示选择y 之后进行混淆插件的设置。 注意：如果协议是origin，那么混淆也必须是plain；如果协议不是origin，那么混淆可以是任意的。有的地区需要把混淆设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）让其看起来像随机数据更好。（特别注意：tls 1.2_ticket_auth容易受到干扰！请选择除tls开头以外的其它混淆！！！） 进行混淆插件的设置后，会依次提示你对设备数、单线程限速和端口总限速进行设置，默认值是不进行限制，个人使用的话，选择默认即可，即直接敲回车键。 注意：关于限制设备数，这个协议必须是非原版且不兼容原版才有效，也就是必须使用SSR协议的情况下，才有效！ 之后代码就正式自动部署了，到下图所示的位置，提示你下载文件，输入：y 耐心等待一会，出现下面的界面即部署完成： 根据上图就可以看到自己设置的SSR账号信息，包括IP、端口、密码、加密方式、协议插件、混淆插件，这些信息需要填入你的SSR客户端。如果之后想修改账号信息，直接输入快捷管理命令：bash ssr.sh 进入管理界面，选择相应的数字来进行一键修改。例如： 脚本演示结束。 此脚本是开机自动启动，部署一次即可。最后可以重启服务器确保部署生效（一般情况不重启也可以）。重启需要在命令栏里输入reboot ，输入命令后稍微等待一会服务器就会自动重启，一般重启过程需要2～5分钟，重启过程中Xshell会自动断开连接，等VPS重启好后才可以用Xshell软件进行连接。如果部署过程中卡在某个位置超过10分钟，可以用xshell软件断开，然后重新连接你的ip，再复制代码进行部署。 第三步：一键加速VPS服务器 此加速教程为谷歌BBR加速,Vultr的服务器框架可以装BBR加速，加速后对速度的提升很明显，所以推荐部署加速脚本。该加速方法是开机自动启动，部署一次就可以了。 按照第二步的步骤，连接服务器ip，登录成功后，在命令栏里粘贴以下代码： 【谷歌BBR加速教程】 yum -y install wget wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 把上面整个代码复制后粘贴进去，不动的时候按回车，然后耐心等待，最后重启vps服务器即可。 演示开始，如图： 复制并粘贴代码后，按回车键确认 如下图提示，按任意键继续部署 部署到上图这个位置的时候，等待3～6分钟 最后输入y重启服务器，如果输入y提示command not found ，接着输入reboot来重启服务器，确保加速生效，bbr加速脚本是开机自动启动，装一次就可以了。 服务器重启成功并重新连接服务器后，输入命令lsmod | grep bbr 如果出现tcp_bbr字样表示bbr已安装并启动成功。如图： 【SSR客户端下载】 第一次电脑系统使用SSR/SS客户端时，如果提示你需要安装NET Framework 4.0，网上搜一下这个东西，安装一下即可。NET Framework 4.0是SSR/SS的运行库，没有这个SSR/SS客户端无法正常运行。有的电脑系统可能会自带NET Framework 4.0。 Windows SSR客户端 下载地址 备用下载地址 MAC SSR客户端 下载地址 备用下载地址 Linux客户端一键安装配置使用脚本(使用方法见注释) 或者采用图形界面的linux ssr客户端 安卓SSR客户端 下载地址 备用下载地址 苹果手机SSR客户端：Potatso Lite、Potatso、shadowrocket都可以作为SSR客户端，但这些软件目前已经在国内的app商店下架，可以用美区的appid账号来下载。但是，如果你配置的SSR账号兼容SS客户端，或者协议选择origin且混淆选择plain，那么你可以选择苹果SS客户端软件（即协议和混淆可以不填），APP商店里面有很多，比如：superwingy、firstwingy、shadowingy、wingy+、banananet、kite-ss proxy、goodshadow、icproyx、shadowrocket等。 有了账号后，打开SSR客户端，填上信息，这里以windows版的SSR客户端为例子： 在对应的位置，填上服务器ip、服务器端口、密码、加密方式、协议和混淆，最后将浏览器的代理设置为（http）127.0.0.1和1080即可。账号的端口号就是你自己设置的，而要上网的浏览器的端口号是1080，固定的，谷歌浏览器可以通过 SwitchyOmega 插件来设置。 启动SSR客户端后，右键SSR客户端图标，选择第一个“系统代理模式”，里面有3个子选项，选择”全局模式“，之后就可以用浏览器设置好了的代理模式（http）127.0.0.1和1080翻墙，此模式下所有的网站都会走SSR代理。 常见问题参考解决方法： 1、用了一段时间发现ssr账号用不了了 首先ping一下自己的ip，看看能不能ping的通，ping不通那么就是ip被墙了，ip被墙时，xshell也会连接不上服务器，遇到这种情况重新部署一个新的服务器，新的服务器就是新的ip。关于怎么ping ip的方法，可以自行网上搜索，或者用xshell软件连接服务器来判断，连不上即是被墙了。vultr开通和删除服务器非常方便，新服务器即新ip，大多数vps服务商都没有这样的服务，一般的vps服务商可能会提供免费更换1次ip的服务。 2、刚搭建好的ssr账号，ip能ping通，但是还是用不了 首选排除杀毒软件的干扰，尤其是国产杀毒软件，比如360安全卫生、360杀毒软件、腾讯管家、金山卫生等。这些东西很容易干扰翻墙上网，如果你的电脑安装了这样的东西，建议至少翻墙时别用，最好卸载。其次，检查下SSR信息是否填写正确。浏览器的代理方式是否是ssr代理，即（HTTP）127.0.0.1 和1080。如果以上条件都排除，还是用不了，那么可以更换端口、加密方式、协议、混淆，或者更换服务器位置。另外，如果你的vps服务器配置的是SSR账号，即有协议和混淆且没有兼容原版(SS版），那么你必须使用SSSR客户端来使用账号，因为SS客户端没有填写协议和混淆的选项。 3、有的地区需要把混淆参数设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）让其看起来像随机数据更好。 4、电脑能用但手机用不了 如果你的手机用的是SS客户端，SS客户端没有填协议和混淆的地方，如果你部署的协议和混淆的时候没有选择兼容原版（SS版），因此手机是用不了的。这个时候你把协议弄成兼容原版、混淆也设置成兼容原版即可。或者直接将协议设置成origin且混淆设置成plain。 5、vps的服务器操作系统不要用的太高，太高可能会因为系统的防火墙问题导致搭建的SSR账号连不上，如果你用的centos系统，建议用centos6，不要用centos7。如果你前面不小心装了centos7系统，那么只能重装系统或者重新部署新的vps服务器。 6、vultr服务商提供的vps服务器是单向流量计算，有的vps服务商是双向流量计算，单向流量计算对于用户来说更实惠。因为我们是在vps服务器上部署SSR服务端后，再用SSR客户端翻墙，所以SSR服务端就相当于中转，比如我们看一个视频，必然会产生流量，假如消耗流量80M，那么VPS服务器会产生上传80M和下载80M流量，vultr服务商只计算单向的80M流量。如果是双向计算流量，那么会计算为160M流量。 7、如果你想把搭建的账号给多人使用，不用额外设置端口，因为一个账号就可以多人使用。一般5美元的服务器可以同时支持40人在线使用。 如果想实现支持每个用户(端口)不同的加密方式/协议/混淆等，并且管理流量使用，可以参考多用户配置脚本：wget -N –no-check-certificate https://softs.fun/Bash/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 备用脚本：wget -N –no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 安装后管理命令为：bash ssrmu.sh 注意：这个多用户配置脚本和教程内容的脚本无法共存！要想用这个脚本，把之前的脚本卸载，输入管理命令bash ssr.sh ，选择3，卸载ShadowsocksR即可卸载原脚本。 8、vultr服务器每月有流量限制，超过限制后服务器不会被停止运行，但是超出的流量会被额外收费。北美和西欧地区的服务器超出流量后，多出的部分收费为0.01美元/G。新加坡和日本东京（日本）为0.025美元/G，悉尼（澳大利亚）为0.05美元/G。把vultr服务器删掉，开通新的服务器，流量会从0开始重新计算。 9、vultr怎样才能申请退款呢？ vultr和其他的国外商家一样，都是使用工单的形式与客服联系，如果需要退款，直接在后台点击support，选择open ticket新开一个工单，选择billing question财务问题，简单的在文本框输入你的退款理由。比如：Please refund all the balance in my account。工单提交以后一般很快就可以给你确认退款，若干个工作日后就会退回你的支付方式。（全额退款结束后，账号可能会被删除） 如果英语水平不好，但是想和客服进行交流，可以用百度在线翻译，自动中文转英文和英文转中文。 10、路由器也可以配置ss/ssr账号，详见openwrt-ssr项目地址：https://github.com/ywb94/openwrt-ssr 11、如果电脑想用搭建的ss/ssr账号玩游戏，即实现类似VPN全局代理，可以用SSTAP，教程：https://www.jianshu.com/p/519e68b74646 教程转载","categories":[{"name":"科技范儿","slug":"科技范儿","permalink":"http://lcccc.com.cn/categories/科技范儿/"}],"tags":[{"name":"SSR自建梯子","slug":"SSR自建梯子","permalink":"http://lcccc.com.cn/tags/SSR自建梯子/"}]},{"title":"React技术栈学习路线","slug":"Reactjsz","date":"2018-09-21T02:55:27.000Z","updated":"2018-09-21T03:03:00.781Z","comments":true,"path":"2018/09/21/Reactjsz/","link":"","permalink":"http://lcccc.com.cn/2018/09/21/Reactjsz/","excerpt":"","text":"React技术栈React阮一峰-React 技术栈系列教程 React入门看这篇就够了 React中文官网 React.js 小书 RouterReact Router 中文文档 React Router 英文文档 Reduxredux-saga Redux 中文文档 Dva（dva 是 react 和 redux 的最佳实践）DvaJS中文官网 我学 dva 那些事儿 dva理论到实践——帮你扫清dva的知识盲点 roadhog —— 让 create-react-app 可配的命令行工具 UmiUmiJS 这并不是全部，待续。。。","categories":[{"name":"React技术栈","slug":"React技术栈","permalink":"http://lcccc.com.cn/categories/React技术栈/"}],"tags":[]},{"title":"Umijs","slug":"Umijs","date":"2018-09-18T12:55:55.000Z","updated":"2018-09-18T12:57:59.313Z","comments":true,"path":"2018/09/18/Umijs/","link":"","permalink":"http://lcccc.com.cn/2018/09/18/Umijs/","excerpt":"","text":"UmiJS(核心：插件机制)UmiJS中文API官网 普通创建安装国内源tyarn $ npm i yarn tyarn -g $ tyarn -v 安装umi $ tyarn global add umi $ umi -v 快速创建page（umi 里==约定==默认情况下 pages 下所有的 js 文件即路由） $ mkdir myapp &amp;&amp; cd myapp $ umi g page index 快速创建dva 的 model umi g dva:model foo 启动本地服务器 $ umi dev 部署发布 $ umi build 通过脚手架创建项目 $ mkdir myapp &amp;&amp; cd myapp $ yarn create umi","categories":[{"name":"React技术栈","slug":"React技术栈","permalink":"http://lcccc.com.cn/categories/React技术栈/"}],"tags":[{"name":"Umijs","slug":"Umijs","permalink":"http://lcccc.com.cn/tags/Umijs/"}]},{"title":"Git相关学习","slug":"Gitstudy","date":"2018-09-17T13:01:35.000Z","updated":"2018-09-17T13:11:41.240Z","comments":true,"path":"2018/09/17/Gitstudy/","link":"","permalink":"http://lcccc.com.cn/2018/09/17/Gitstudy/","excerpt":"","text":"Git相关学习 推荐-梁雪峰Git教程官方文档安装官方Downloads 安装后配置你的用户名、密码 $ git config –global user.name “Your Name” $ git config –global user.email “email@example.com“ 工具（小乌龟）下载链接 Git客户端(TortoiseGit)基本使用详解 创建版本库创建空文件夹容器 $ mkdir learngit $ cd learngit $ pwd 通过git init命令把这个目录变成Git可以管理的仓库 $ git init Mac上显示隐藏文件命令 $ defaults write com.apple.finder AppleShowAllFiles TRUE $ killall Finder or ==ls -ah==命令 在所创目录文件下创建文件添加文件到Git仓库，分两步： $ git add readme.txt $ git commit -m “wrote a readme file” 版本回退显示从最近到最远的提交日志(在Git中，用==HEAD==表示当前版本) $ git log –author = name 回退命令 $ git reset –hard HEAD^ 远程仓库创建SSH KEY $ ssh-keygen -t rsa -C “youremail@example.com“ $ open ~/.ssh 命令直接打开 把本地仓库的内容推送到GitHub仓库。 $ git remote add origin git@github.com:michaelliao/learngit.git $ git push -u origin master git如何解决failed to push some refs to git可以通过如下命令进行代码合并【注：pull=fetch+merge] git pull –rebase origin master 三步走： $ git add readme.txt $ git commit -m “wrote a readme file” $ git push origin master git如何上传所有的新文件 $ git status $ git add -A $ git commit -a -m”first commit” $ git push origin master git add上传本地项目所有变化的命令三种 git add -A 提交所有变化 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 后续。。补充。。","categories":[{"name":"工具","slug":"工具","permalink":"http://lcccc.com.cn/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://lcccc.com.cn/tags/Git/"}]},{"title":"Ant Design Pro 2.0","slug":"Ant Design Pro 2.0","date":"2018-09-13T03:15:52.000Z","updated":"2018-09-18T12:58:34.841Z","comments":true,"path":"2018/09/13/Ant Design Pro 2.0/","link":"","permalink":"http://lcccc.com.cn/2018/09/13/Ant Design Pro 2.0/","excerpt":"","text":"Ant Design Pro 2.0主要改进和改变详看官网安装 $ git clone –depth=1 https://github.com/ant-design/ant-design-pro.git my-project $ cd my-project $ npm install $ npm start 使用cnpm加速 $ npm install -g cnpm –registry=https://registry.npm.taobao.org 目录结构","categories":[{"name":"React技术栈","slug":"React技术栈","permalink":"http://lcccc.com.cn/categories/React技术栈/"}],"tags":[{"name":"Ant Design Pro 2.0","slug":"Ant-Design-Pro-2-0","permalink":"http://lcccc.com.cn/tags/Ant-Design-Pro-2-0/"}]},{"title":"自己热衷的一款Markdown工具-有道云笔记","slug":"mdyoudao","date":"2018-09-12T12:44:15.000Z","updated":"2018-09-12T13:17:23.025Z","comments":true,"path":"2018/09/12/mdyoudao/","link":"","permalink":"http://lcccc.com.cn/2018/09/12/mdyoudao/","excerpt":"","text":"自己热衷的一款Markdown工具-有道云笔记之前有使用过SbulimeText但是效果并不是那么理想。首先，原生的ST并不能在写md文件时预览，要想实现预览功能还得安装插件（懒得折腾）其次最不方便的就是没有实现效果的快捷方式，比如我想插入一张图片，一个链接地址。但是在打开md或其他文件还是挺方便的。有道云笔记作为一个国产工具，不得不说还是相当优秀的，至少现在的我是这样亲身感受的。不仅可以记录笔记还可以作为一款Markdown工具，真是不要太完美。 下载地址 效果就是如此。想要写出怎样的页面效果，直接看Markdwon Api文档就行，不用深入，了解就行","categories":[{"name":"工具","slug":"工具","permalink":"http://lcccc.com.cn/categories/工具/"}],"tags":[{"name":"编辑工具","slug":"编辑工具","permalink":"http://lcccc.com.cn/tags/编辑工具/"}]},{"title":"科学上网-使用Google搜索","slug":"chromsearch","date":"2018-09-11T09:13:43.000Z","updated":"2018-09-11T09:27:03.348Z","comments":true,"path":"2018/09/11/chromsearch/","link":"","permalink":"http://lcccc.com.cn/2018/09/11/chromsearch/","excerpt":"","text":"科学上网-使用Google搜索百度搜索在国内知名度是非常高的，但是用过的都知道，内嵌的广告会误导我们。跟Chrome简直没法比（Chrome全球份额60%啊，想想都可怕）由于一些因素，大家都懂的。国内正常情况下无法使用Chrome搜索。上有政策，下有对策嘛。今天推荐一个插件，安装好了就可以…嘻嘻。 谷歌访问助手下载解压出的Crx文件拖进浏览器即可，不会自行谷歌。搜索那就自由发挥啦。 遗憾的是YouTube是不支持访问的，只支持Chrome搜索和Chrome商店的访问，商店里可以下载一些有用的插件，这里推荐一个超好用的。 Infinity 新标签页 有需的插件可以自行搜索。感觉Google的解析太快了，可能是错觉。哈哈","categories":[{"name":"科技范儿","slug":"科技范儿","permalink":"http://lcccc.com.cn/categories/科技范儿/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://lcccc.com.cn/tags/Chrome/"}]},{"title":"ES6绑定this的三种方式","slug":"ES6_bind","date":"2018-09-11T02:25:52.000Z","updated":"2018-09-11T06:10:35.167Z","comments":true,"path":"2018/09/11/ES6_bind/","link":"","permalink":"http://lcccc.com.cn/2018/09/11/ES6_bind/","excerpt":"","text":"0.React绑定this的三种方式0.1 bind()handleClick (name, e) { console.log(this.state.message + name) } render () { return ( &lt;div&gt; &lt;button onClick={ this.handleClick.bind(this, &apos;赵四&apos;) }&gt;Say Hello&lt;/button&gt; &lt;/div&gt; ) } 0.2 构造函数内绑定handleClick (e) { console.log(this.state.message) } render () { return ( &lt;div&gt; &lt;button onClick={ this.handleClick }&gt;Say Hello&lt;/button&gt; &lt;/div&gt; ) } 0.3 箭头函数(es6语法，用得最多)handleClick = (e) =&gt; { console.log(this.state.message) } render () { return ( &lt;div&gt; &lt;button onClick={ this.handleClick }&gt;Say Hello&lt;/button&gt; &lt;/div&gt; ) } 0.4 箭头函数传参render () { return ( &lt;div&gt; &lt;button onClick={ ()=&gt;this.handleClick(&apos;参数&apos;) }&gt;Say Hello&lt;/button&gt; &lt;/div&gt; ) }","categories":[{"name":"web前端","slug":"web前端","permalink":"http://lcccc.com.cn/categories/web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://lcccc.com.cn/tags/ES6/"}]}]}